# Pre-deployment validation and secrets fetch
# Uses container_commands which run after app staging but before Procfile start

commands:
  01_create_deployment_dir:
    command: mkdir -p /opt/elasticbeanstalk/deployment && chmod 755 /opt/elasticbeanstalk/deployment

container_commands:
  00_fetch_secrets:
    command: |
      #!/bin/bash
      set -e

      echo "=========================================="
      echo "FETCHING SECRETS FROM SECRETS MANAGER"
      echo "$(date): Starting secrets fetch..."
      echo "=========================================="

      # Source EB environment if available
      if [ -f /opt/elasticbeanstalk/deployment/env ]; then
        . /opt/elasticbeanstalk/deployment/env
      fi

      AWS_REGION="${AWS_REGION:-us-east-1}"
      ENV_FILE="/opt/elasticbeanstalk/deployment/custom_env"

      # Clear previous custom env file
      > $ENV_FILE
      chmod 644 $ENV_FILE

      echo "DB_SECRET_ARN: ${DB_SECRET_ARN:-NOT SET}"
      echo "DJANGO_SECRET_ARN: ${DJANGO_SECRET_ARN:-NOT SET}"
      echo "APP_CONFIG_SECRET_ARN: ${APP_CONFIG_SECRET_ARN:-NOT SET}"

      # Function to fetch secret with error handling
      # Note: Status messages go to stderr (>&2) so only JSON goes to stdout
      fetch_secret() {
        local secret_arn="$1"
        local secret_name="$2"

        if [ -z "$secret_arn" ]; then
          echo "WARNING: $secret_name ARN not set, skipping" >&2
          return 0
        fi

        echo "Fetching $secret_name from $secret_arn..." >&2
        local result
        result=$(aws secretsmanager get-secret-value \
          --secret-id "$secret_arn" \
          --query SecretString \
          --output text \
          --region "$AWS_REGION" 2>&1)

        if [ $? -ne 0 ]; then
          echo "ERROR: Failed to fetch $secret_name: $result" >&2
          return 1
        fi

        echo "$result"
      }

      # Helper to safely write env var (escapes special chars using single quotes)
      write_env() {
        local name="$1"
        local value="$2"
        # Use single quotes and escape any embedded single quotes
        local escaped_value="${value//\'/\'\\\'\'}"
        echo "export ${name}='${escaped_value}'" >> $ENV_FILE
      }

      # Get database credentials
      if [ -n "$DB_SECRET_ARN" ]; then
        DB_SECRET=$(fetch_secret "$DB_SECRET_ARN" "database credentials") || exit 1
        DB_HOST=$(echo $DB_SECRET | jq -r '.host')
        DB_PORT=$(echo $DB_SECRET | jq -r '.port')
        DB_NAME=$(echo $DB_SECRET | jq -r '.dbname')
        DB_USER=$(echo $DB_SECRET | jq -r '.username')
        DB_PASS=$(echo $DB_SECRET | jq -r '.password')

        if [ -z "$DB_HOST" ] || [ "$DB_HOST" = "null" ]; then
          echo "ERROR: Database host not found in secret"
          exit 1
        fi

        echo "OK: Database credentials fetched (host: $DB_HOST)"
        # Use postgresql:// (dj_database_url doesn't support +psycopg suffix)
        # Django automatically uses psycopg v3 if installed
        write_env DATABASE_URL "postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}/${DB_NAME}"
      else
        echo "WARNING: DB_SECRET_ARN not set"
      fi

      # Get Django secret key
      if [ -n "$DJANGO_SECRET_ARN" ]; then
        DJANGO_SECRET=$(fetch_secret "$DJANGO_SECRET_ARN" "Django secret key") || exit 1
        SECRET_KEY=$(echo $DJANGO_SECRET | jq -r '.secret_key')

        if [ -z "$SECRET_KEY" ] || [ "$SECRET_KEY" = "null" ]; then
          echo "ERROR: Secret key not found in secret"
          exit 1
        fi

        echo "OK: Django secret key fetched"
        write_env SECRET_KEY "$SECRET_KEY"
      fi

      # Get app config
      if [ -n "$APP_CONFIG_SECRET_ARN" ]; then
        APP_CONFIG=$(fetch_secret "$APP_CONFIG_SECRET_ARN" "app config") || exit 1

        API_URL=$(echo $APP_CONFIG | jq -r '.api_url // empty')
        WEB_URL=$(echo $APP_CONFIG | jq -r '.web_url // empty')
        CORS_ORIGINS=$(echo $APP_CONFIG | jq -r '.cors_allowed_origins // empty')
        ALLOWED_HOSTS=$(echo $APP_CONFIG | jq -r '.allowed_hosts // empty')
        DEBUG_RAW=$(echo $APP_CONFIG | jq -r '.debug // "false"')
        # Convert boolean to integer (Django expects 0 or 1, not True/False)
        if [ "$DEBUG_RAW" = "True" ] || [ "$DEBUG_RAW" = "true" ] || [ "$DEBUG_RAW" = "1" ]; then
          DEBUG="1"
        else
          DEBUG="0"
        fi

        [ -n "$API_URL" ] && write_env API_BASE_URL "$API_URL"
        [ -n "$WEB_URL" ] && write_env WEB_URL "$WEB_URL"
        [ -n "$CORS_ORIGINS" ] && write_env CORS_ALLOWED_ORIGINS "$CORS_ORIGINS"
        [ -n "$ALLOWED_HOSTS" ] && write_env ALLOWED_HOSTS "$ALLOWED_HOSTS"
        write_env DEBUG "$DEBUG"

        echo "OK: App config fetched"
      fi

      # Redis configuration
      if [ -n "$REDIS_URL" ]; then
        write_env REDIS_URL "$REDIS_URL"
        echo "OK: Redis URL set"
      fi

      echo ""
      echo "CUSTOM_ENV FILE CREATED:"
      cat $ENV_FILE | sed 's/\(PASSWORD\|SECRET_KEY\)="[^"]*"/\1="***REDACTED***"/g'
      echo ""
      echo "=========================================="
      echo "SECRETS FETCH COMPLETE"
      echo "=========================================="
    leader_only: false
